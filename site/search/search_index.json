{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"General","text":""},{"location":"#overview","title":"Overview","text":"<p>This documentation is for Cheer Supports app IOS version.</p> <p>This mobile application is the application of the Cheer Supports Website. It has been developed using the web-view method to ensure familiarity and display information about the events regularly and automatically. It also has additional features to cover the minimum features and requirements of a web-view app to publish in the Apple Store.</p> <p>Check more details about App Review Guidelines. </p> <p>Application features: </p> <ul> <li>In app login system</li> <li>In app chat system</li> <li>Daily tracking system </li> <li>Daily task system</li> <li>Rewards system</li> <li>Simple Leveling system</li> <li>In app usage only items</li> <li>In app purchase with Apple Pay</li> <li>Has notification system </li> <li>Has own point system for purchasing in app item</li> </ul> <p>Cheer Support App Repository</p>"},{"location":"#app-settings","title":"App Settings","text":"<p>Min IOS Deployment Target : 15.1</p> <p>Bundle Identifier : com.Kyi.Co.Ltd.Jp.Cheer-Supports</p> <p>Capabitilities : </p> <ul> <li>Background Modes [ Background fetch, Remote Notification, Background processing ]</li> <li>In-App Purchase</li> <li>Push Notification</li> </ul> <p>Operation System: MacOS</p> <p>IDE: Xcode</p> <p>Programming Language: Swift</p> <p>Framework: SwiftUI</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li> <p>Either use this step  Install GitHub Desktop software MacOS  Follow this steps for cloning repository.</p> </li> <li> <p>Or use command-line tools (terminal)</p> </li> </ul> <p><pre><code>git clone --single-branch --branch features/NewIOSVersion https://github.com/kyi-developers-organization/Cheer-Supports-Mobile-App.git\n</code></pre> This command line will clone ios xcode project only.</p>"},{"location":"#dependecies","title":"Dependecies","text":"<ul> <li> <p>Bottom Sheet -&gt; version 3.1.1 <pre><code>https://github.com/lucaszischka/BottomSheet.git\n</code></pre></p> </li> <li> <p>Firebase SDK -&gt; version 10.19.1 <pre><code>https://github.com/firebase/firebase-ios-sdk.git\n</code></pre></p> </li> <li> <p>SDWebImage SwiftUi -&gt; version 3.0.2 <pre><code>https://github.com/SDWebImage/SDWebImageSwiftUI.git\n</code></pre></p> </li> <li> <p>GoogleAPI Auth -&gt;  version 0.5.3 <pre><code>https://github.com/googleapis/google-auth-library-swift.git\n</code></pre></p> </li> </ul> <p>SPM Screenshot</p>"},{"location":"#project-layout","title":"Project layout","text":"<p>This is full navigation layout</p>"},{"location":"#home","title":"Home","text":"<p>Home is linked to Profile,  Chat, Cheer --&gt; Items and Settings views through buttons.</p> <p>Home page has 2 main stack view. First is contain webview, Second one is contain ui buttons. For better visualization about stack views check this image User has to be login both app and website login system otherwise streaming button will popup Signin view.  Users can register through website. </p>"},{"location":"#profile","title":"Profile","text":"<p>Profile is linked to Daily Tasks, Signin, Exp Purchase and Cheer through the buttons. </p> <p>This view divided 3 main stack views. User level section has Login button link to Sigin view. All user informations are saved Firebase DB --&gt; Users --&gt; UUID (uniqe id generated by Firebase).</p> <p>Reward Section contain only ui views.</p> <p>Level up section is has 3 buttons and linked to exp card purchase view, daily tasks view and Cheer purchase view respectively.  </p>"},{"location":"#daily-tasks","title":"Daily Tasks","text":"<p>Daily is only linked to Profile view. Divided 3 main stack views.  User Info section;  most of datas are retrieve from Firebase database, only cheer data value retrieve from AWS database. Daily Login section; contain UI view and related functions. Daily Missions section; Information about mission and button for collecting reward, buttons are will active when user finised the task otherwise will be inactive. Active buttons color is orange, inactive buttons color is gray. Every task has different shop points and exp point.</p>"},{"location":"#chat-room","title":"Chat Room","text":"<p>Chat is linked to Signin and Home through to butttons in Top section view. Chat section shows list of the message save in Firebase --&gt; Msgs documents. Bottom section; image picker and emoji view list hidden under plus \"+\" button and send button will hidden until user type any text or select any image(or emoji).  Top section and Section backgrounds are synchronized with ui button style. </p>"},{"location":"#cart","title":"Cart","text":"<p>Shop Cart has simple stack view tab buttons and view sections view section. View section shows cheer purchase view (default view) and app item purchase view. The shop cart view is linked only to the home view. Other content shows as a subview using the Bottom Sheet plugin. The toolbar contains shop points and the total cheer the user has. </p>"},{"location":"#cheer-purchase","title":"Cheer Purchase","text":"<p>There are 7 Cheer purchase products available.  500, 1000, 3000, 5000, 10000, 30000, and 50000 products are listed in view. If the user not logged in it will shows a notification. After successfulll purchase it will shows a notification.   </p>"},{"location":"#app-items-purchase","title":"App Items Purchase","text":"<p>There are 6 subview exist in App Item View. All subviews has 2 detents; medium and large.  Detents are dynamically adjusted the subview height. </p> <p>There are 3 purchase notification;</p> <ul> <li>Not enough Cheer or shopping Point</li> <li>Already have item</li> <li>Successfully purchased </li> </ul> <p>these notification are implemented in all app item purchase system.  </p>"},{"location":"#exp-purchase","title":"Exp Purchase","text":"<p>Simple a stack view with a purchase button. Detents set medium as default value. The maximum number of card purchases at a time has been determined as 99. </p>"},{"location":"#exp-multiply","title":"Exp Multiply","text":"<p>A view contain 3 stack views. Stack view contain information text and button. On button click it will show a confirmation dialog. </p>"},{"location":"#ui-style","title":"UI Style","text":"<p>There are 3 main stack views. These are button styles(3 items), background images(6 items) and backround color(6 items). All items can be purchased either with Cheer or Point. On Items click will show purchase options dialog. Every item group prices are different, button styles are each 500 Cheer or 500 Point, background images are each 200 Cheer or Point and background colors are each 50 Cheer or Point. Button Styles are set with a uniqe background images and background images and background color can be used in chat room background settings.</p>"},{"location":"#font-style","title":"Font Style","text":"<p>There are 2 main stack views.  These are font colors (6 items) and font styles(4 items). All items can be purchased either with Cheer or Point. On Items click will show purchase options dialog. Every items can be purchase  50 Cheer or 50 Point. Font style and font color can effect chat message text style. </p> <p>Note: Currently font style not effect logographic kanjis and furigana</p>"},{"location":"#emojis","title":"Emojis","text":"<p>There are 5 items using same view model within only stack view shows a list view. List items are clickable and show full list of the emoji group items. Items can be purhcase with cheer only and each emoji group is cost 500 cheer. On list clicked will show a popover. </p>"},{"location":"#animated-emojis","title":"Animated Emojis","text":"<p>There are 5 items using same view model within only stack view shows a list view. List items are clickable and show full list of the emoji group items. Items can be purhcase with cheer only and each emoji group is cost 1000 cheer. On list clicked will show a popover. </p>"},{"location":"#settings","title":"Settings","text":"<p>Settings is connected Home and Item views. Settings is divided for 3 sections. </p> <ol> <li>General</li> <li>Blocked User </li> <li>Others</li> </ol> <p>General section currently contain only owned items. Can find more detals in Items (Navigate to Items).</p> <p>Blocked Users has only list of the blocked users.</p> <p>Others section has 3 settings one of them share the application. the other is a toogle for showing level log in chat room view. When user reach level 2 it will automaticly will turn on. And last one is delete the account; this settings is required to publish the application in App Store. Delete the account is requests the deletion of data from both Firebase and AWS databases. </p>"},{"location":"#items","title":"Items","text":"<p>Item Lists Owned Items connect to Settings view. Divided 4 section with section header. All datas are saved in Owned Items array of users Firebase data collection. All settings effects only app view and styles, there is no effect on Cheer Supports webview also chat items cannot be use in streaming chat.</p> <ol> <li> <p>Background; This is for chat room message area background design settings. Onclick shows a menu, if the user has any color or image will show the submenu as Color or Images, and other default and cancel options available in the menu view list. \"Background\" text is clickable. For better performace all Horizontal Stack view should be button. </p> </li> <li> <p>Button; This is change set style for home button ui view style and also chat room top bar and bottom bar ui view. If user has any style it will shows a menu option with name.</p> </li> <li> <p>Font; There are 2 settings in this section font style and font color. Onclick shows a menu, if user has any font style or color will show the name in related menu. Current font styles are not effected furigana and kanjis. Need to add new styles for both Japanese and Chinese languages and Font Style Item view in shop should also changed based on language.</p> </li> <li> <p>Chat Items; Currently we have emojis and animated emojis items can be used in the app chat system. It is a dropdown list and shows a list of chat items purchased as text. List items are non-clickable.</p> </li> </ol>"},{"location":"#future-of-app","title":"Future of App","text":"<p>There are a couple of features that need to be added and some that need to be updated for better app quality. It will be divided into 2 sections New Features and Updates Required Features. Couldn't put the app in stress tests. Based on my testing some features consume too much RAM for example animated emojis in the empty chat consume an average 30 mb when adding images or animated emojis it will rise to 100 mb. By following SDWebImageSwiftUI documentation instructions for cache managing decrease ram usage to 70 mb. Need additional measurements to further decrease for better performance. Some features need to be added (some of them are requested from the client). </p>"},{"location":"#updates-required-features","title":"Updates Required Features","text":"<p>All of these suggestions are for better user experience and better app performance.  Feel free to implement solutions If you notice different issue(s) or have better solutions. Overall we are developers, and building the best products is our first task.</p> <ul> <li> <p>Webview is loading slowly. Excluding external reasons (non-app related reasons like wireless connection speed, connection signal quality, mobile phone CPU speed, RAM capacity of the phone, IOS version, etc.) there are multiple solutions to improve app quality. </p> <ol> <li>Webview app speed is directly linked to website performance. Therefore improve website load speed.</li> <li>By decreasing task requests before the app launch.</li> <li>Better user experiences add a loading image or some images can hide the loading process. Hide the image when webview is fully loaded.</li> </ol> </li> <li> <p>Animated Emojis consume too much RAM therefore certain views need attention. Global Chat, ShopView/Animated Emojis view are currently using SDWebImageSwiftui. </p> <ol> <li>Show limited messages in history of the messages.</li> <li>Play once or twice animated images. </li> <li>On tap gesture play selected emojis animation.</li> <li>Stop playing all animated emojis when the user saw the list.  </li> </ol> </li> <li> <p>Change the Full design of Shop Cart View. The current Bottom Sheet plugin response is not good enough.</p> <ol> <li>Change the bottom sheet view system to a navigation link system.</li> <li>Native sheet detents (medium and large) options are available IOS version 16.0 or later. Either change the minimum target version from 15.1 to 16.0 to create a dynamic detents system.  </li> </ol> </li> <li> <p>Add more emojis.</p> </li> <li> <p>Add more animated emojis.</p> </li> <li> <p>Add more UI styles. Current font styles are working on romaji letters, add more font styles, especially for furigana and kanji. </p> </li> <li> <p>Update settings UI view with better design.</p> </li> <li> <p>Replace the webview system with an application-specific system with new ui design and with synchronized current website database.</p> </li> </ul>"},{"location":"#new-features","title":"New Features","text":"<p>Before explaining new features there are a few points that need to mention. Before started developing the mobile application there was a conversation about changing Cheer Support web content. At first idea was a full renewal of the web content and then middle of development it is changed to re-design. Those are 2 different approaches. Because of the uncertainty mobile app structure becomes more restricted.</p> <p>Renewal is changing all structures, API routes, UI design, and database of the web content. Anything related back-end will directly affect the mobile application.  </p> <p>Redesigning, on the other hand, affects the user's view of web content. While this approach has a potential impact on the backend, it will be limited and, therefore on impact the mobile app also limited. </p> <p>Members who could work were limited. I worked with only one graphic designer on this project. He creates most of the images, emojis and animated emojis, the rest is done solely by me. There was only one front-end developer in the web content, but she was working as a full-stack developer. So working with her also was out of the option.</p> <p>There were requests from the CEO and client. Most of them are already done and there are 2 features left to implement for finishing the app. There are preparations to be made before adding these features, as well as the completion of the redesign of the website and the completion of the back-end related new design.</p> <ul> <li> <p>At the time of writing this document, there were 7 WebGL applications in the web content. All WebGL applications are developed with a cross-platform called Unity Game Engine. These applications do not work on mobile browsers and the CEO requested that these applications be available on mobile devices. To achieve this those are the preparations required;</p> <ol> <li>Convert to WebGL application to IOS application</li> <li>Optimized the app for mobile (for example occlusion culling, lightmap, decrease the RAM usage ...)</li> <li>Add UI and controller system for mobile app use</li> <li>Decrease the size of the app (There is a maximum size limit to upload the App Store)</li> </ol> </li> </ul> <p>The above steps should be followed for 6 applications. WebGL applications called Hoshiyomi are already published on the App Store and Play Store.</p> <ul> <li> <p>Add the Augmented Reality future with body and face tracking to the live-streaming feature. </p> </li> <li> <p>Add noice cancelling feature to live-streaming.</p> </li> </ul>"},{"location":"example/","title":"Examples","text":""},{"location":"technical/","title":"Technical","text":""},{"location":"technical/#specification","title":"Specification","text":"<ol> <li> <p>This application developed on IOS 15.1 - 17.4 - using Swift / Objective-C - with SwiftUI framework</p> </li> <li> <p>This applicaiton is intended for use smartphone only, in a portrait orientation.</p> </li> <li> <p>JSON requests are used to handle the communication between the app and servers.</p> </li> <li> <p>This application works only in online mode.</p> </li> <li> <p>Push notifications are handled by Firebase.</p> </li> <li> <p>Real-time messages are handled by Firebase.</p> </li> <li> <p>User Daily Login informations are handled by Firebase, all information mobile application usage related only.</p> </li> <li> <p>New User registration can be done webview only. </p> </li> <li> <p>Webview datas are handled by AWS</p> </li> <li> <p>In app purchase system is implemented the mobile application only</p> </li> </ol>"},{"location":"technical/#key-features","title":"Key Features","text":""},{"location":"technical/#webview-feature","title":"Webview Feature","text":"<p>To show that Cheer Supports web content on mobile I used an open-source web browser engine called Webkit. WebKit is a browser engine primarily used in Apple's Safari web browser, as well as all web browsers on iOS and iPadOS. Cheer Supports web content is changing frequently and to keep up with the web content updates webview was the best choice. All scripts related webview is separeated from the others and they under 'Webservices' folder. Folder contain \"WebView\", \"WebViewModel\", \"APIService\" and AccountServiceViewModel script files. </p>"},{"location":"technical/#webview-script","title":"WebView Script","text":"<p>The WebView struct is a SwiftUI component designed to display web content using WKWebView, which is part of the WebKit framework. It integrates into SwiftUI views to render web pages specified by a URL and provides functionality for observing URL changes, handling navigation, and interacting with JavaScript.</p>"},{"location":"technical/#struct-webview","title":"Struct: WebView","text":"<p>The WebView struct conforms to UIViewRepresentable, making it compatible with SwiftUI's view hierarchy. Properties</p> <ul> <li>url: A String property representing the main URL to be loaded initially.</li> <li>webVM: An instance of WebViewModel used to manage state and interactions with the web view.</li> </ul>"},{"location":"technical/#methods","title":"Methods","text":"<ul> <li> <p>makeUIView: Initializes and configures the WKWebView instance. Sets up configuration for media playback and JavaScript interaction permissions. Observes URL changes and updates the webVM's current_url property.</p> </li> <li> <p>updateUIView: Updates the WKWebView instance with a new URL when the url property changes.</p> </li> <li> <p>makeCoordinator: Creates and returns an instance of the Coordinator class, which acts as the delegate for the WKWebView and handles navigation events.</p> </li> </ul>"},{"location":"technical/#class-coordinator","title":"Class: Coordinator","text":"<p>The Coordinator class manages interactions and events within the WKWebView instance. Properties</p> <ul> <li>parent: A reference to the parent WebView instance.</li> <li>observer: An optional NSKeyValueObservation instance to observe URL changes in the web view.</li> </ul>"},{"location":"technical/#methods_1","title":"Methods","text":"<ul> <li> <p>webView(_:didFail:withError:): Delegate method called when navigation to a URL fails. Prints the error message.</p> </li> <li> <p>webView(_:didFinish:): Delegate method called when web view finishes loading a URL. Prints a success message.</p> </li> <li> <p>webView(_:createWebViewWith:for:windowFeatures:): Delegate method to handle creating a new web view for navigation actions that target a new frame.</p> </li> <li> <p>webView(_:didReceiveServerRedirectForProvisionalNavigation:): Delegate method called when the web view receives a server redirect during navigation. Prints the redirected URL.</p> </li> </ul>"},{"location":"technical/#extension-wkwebview","title":"Extension: WKWebView","text":"<p>An extension on WKWebView provides additional functionality to create JSON data from a dictionary. Methods</p> <ul> <li>createJsonData(for:): Converts a dictionary [String:Any] into a JSON string, removing unnecessary whitespace and newline characters.</li> </ul>"},{"location":"technical/#usage","title":"Usage","text":"<p>To use the WebView component in a SwiftUI view, initialize it with a url and webVM instance. Example usage: <pre><code>struct ContentView: View {\n    @StateObject private var webVM = WebViewModel()\n\n    var body: some View {\n        WebView(url: \"https://www.example.com\", webVM: webVM)\n            .onAppear {\n                // Additional setup when the web view appears\n            }\n    }\n}\n</code></pre></p> <p>Considerations:</p> <ul> <li>Ensure proper handling of JavaScript interactions and permissions based on application requirements.</li> <li>Monitor for potential memory leaks when using observers and delegates.</li> <li>Test thoroughly across different web content to ensure compatibility and responsiveness.</li> </ul> <p>This documentation outlines the structure, functionality, and usage considerations for integrating a web view within a SwiftUI application using the WebView struct.</p>"},{"location":"technical/#webviewmodel","title":"WebViewModel","text":""},{"location":"technical/#overview","title":"Overview","text":"<p>The WebViewModel.swift file contains the WebViewModel class, which serves as a bridge between SwiftUI components and the WKWebView for managing web content interactions. It includes methods for reloading, navigating, and interacting with local storage within the web view.</p>"},{"location":"technical/#class","title":"Class","text":"<p>The WebViewModel class extends NSObject and conforms to ObservableObject and WKNavigationDelegate, facilitating communication between SwiftUI views and the web view.</p>"},{"location":"technical/#properties","title":"Properties","text":"<ul> <li>current_url: A @Published property that stores the current URL loaded in the web view.</li> <li>webView: An optional WKWebView instance. Setting this property assigns the navigation delegate to self.</li> </ul>"},{"location":"technical/#methods_2","title":"Methods","text":"<ul> <li> <p>reload(): Reloads the current web page.</p> </li> <li> <p>goBack(): Navigates back to the previous web page.</p> </li> <li> <p>getCurrentURL(): Retrieves the URL of the current web page.</p> </li> <li> <p>setLocalStorage(name: id: token: ): Stores user data in the browser's local storage using JavaScript. Converts a dictionary to JSON format and injects it into the local storage.</p> </li> <li> <p>getLocalStorage(): Retrieves data from the browser's local storage using JavaScript.</p> </li> <li> <p>clearLocalStorage(): Clears all data from the browser's local storage using JavaScript.</p> </li> </ul>"},{"location":"technical/#delegate-methods","title":"Delegate Methods","text":"<ul> <li> <p>webView(_:didFail:withError:): Delegate method called when web view navigation fails. Prints the error message if navigation fails.</p> </li> <li> <p>webView(_:didFinish:): Delegate method called when web view finishes loading a URL. Handles necessary actions upon successful navigation.</p> </li> </ul>"},{"location":"technical/#usage_1","title":"Usage","text":"<p>To use WebViewModel in a SwiftUI application, instantiate it and use its methods to interact with the embedded WKWebView.</p> <p>Example: </p> <pre><code>struct ContentView: View {\n    @StateObject private var webVM = WebViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Current URL: \\(webVM.current_url)\")\n            Button(\"Reload\") {\n                webVM.reload()\n            }\n            Button(\"Go Back\") {\n                webVM.goBack()\n            }\n            Button(\"Get Local Storage\") {\n                webVM.getLocalStorage()\n            }\n        }\n        .onAppear {\n            // Setup initial web view configuration\n            let webView = WKWebView()\n            webVM.webView = webView\n\n            // Load initial URL\n            let initialURL = URL(string: \"https://www.example.com\")!\n            webView.load(URLRequest(url: initialURL))\n        }\n    }\n}\n</code></pre>"},{"location":"technical/#considerations","title":"Considerations","text":"<ul> <li>Ensure proper handling of optional values when accessing webView property.</li> <li>Manage JavaScript interactions cautiously, especially with sensitive user data stored in local storage.</li> <li>Test thoroughly across different web scenarios to verify functionality and error handling.</li> </ul> <p>This documentation provides an overview of WebViewModel.swift, describing its purpose, properties, methods, and usage within a SwiftUI context. It outlines how to interact with web views and manage local storage effectively.</p>"},{"location":"technical/#apiservice","title":"APIService","text":""},{"location":"technical/#overview_1","title":"Overview","text":"<p>The Webservice.swift file encapsulates various API request functions and handles corresponding responses for the \"Cheer Supports\" application. It uses Swift's URLSession and Combine framework for asynchronous networking tasks, ensuring efficient communication with the backend services.</p>"},{"location":"technical/#class_1","title":"Class","text":"<p>The APIService class contains methods for making API requests to different endpoints, processing responses, and handling errors. Each method corresponds to a specific API route within the application.</p>"},{"location":"technical/#properties_1","title":"Properties","text":"<p>None.</p>"},{"location":"technical/#methods_3","title":"Methods","text":"<ul> <li> <p>getUserAvatar(token:):</p> <ul> <li>Route: 195 (User information)</li> <li>Purpose: Retrieves the avatar URL for a user.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Fetches user avatar details from the server using HTTP GET request and returns the avatar URL as a String.</li> </ul> </li> <li> <p>getUserProfile(token:):</p> <ul> <li>Route: 129 (User profile information)</li> <li>Purpose: Retrieves user profile information, specifically live streaming status.</li> <li>Throws: PathError.noData, PathError.invalidUrl</li> <li>Description: Sends a GET request to fetch user profile data and returns an array of Route129Response objects.</li> </ul> </li> <li> <p>getLoginDatas(email:password:completion:):</p> <ul> <li>Route: 100 (Login)</li> <li>Purpose: Performs user login and retrieves user ID, token, and nickname upon successful authentication.</li> <li>Throws: No direct throws, uses completion handler for AuthenticationError cases.</li> <li>Description: Sends a POST request with login credentials, handles the response asynchronously using URLSession, and provides results through a completion handler.</li> </ul> </li> <li> <p>checkCurrentPoint(user_id:token:):</p> <ul> <li>Route: 198 (Get user current points)</li> <li>Purpose: Retrieves the current cheer coins for a user.</li> <li>Throws: AuthenticationError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch user's current cheer coins based on user ID and token, returning the amount as a String.</li> </ul> </li> <li> <p>sendEncodedData(encoded_key:token:completion:):</p> <ul> <li>Route: 601 (Decrypt the purchase key)</li> <li>Purpose: Decrypts a purchase key for in-app payment.</li> <li>Throws: PurchaseError.invalidUrl, PurchaseError.invalidKey</li> <li>Description: Sends a POST request to decrypt an encoded key using a token, handling the response asynchronously through a completion handler.</li> </ul> </li> <li> <p>sendCheerDeductionInformations(user_id:token:quantity:price:platform:item_id:completion:):</p> <ul> <li>Route: 602 (Update the Cheer)</li> <li>Purpose: Deducts cheer points upon item purchase in the application.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a POST request to update cheer points deduction, handling the response asynchronously through a completion handler.</li> </ul> </li> <li> <p>deleteAccountRequest(user_id:token:):</p> <ul> <li>Route: 132 (Account deletion request)</li> <li>Purpose: Sends a request to delete a user account.</li> <li>Throws: No direct throws, prints error message for invalid API URL.</li> <li>Description: Sends a POST request to initiate an account deletion request using user ID and token.</li> </ul> </li> <li> <p>getFollowListCount(user_id:token:):</p> <ul> <li>Route: 196 (Follow list count)</li> <li>Purpose: Retrieves the count of users a particular user is following.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch the count of users followed by a specified user, returning a Route196Response object.</li> </ul> </li> <li> <p>getLastStreaming(user_id:token:):</p> <ul> <li>Route: 603 (Last Streaming Date)</li> <li>Purpose: Retrieves the last streaming date for mission reward calculations.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch the last streaming date of a user based on user ID and token, returning a Route603Response object.</li> </ul> </li> <li> <p>getWatchedStreams(user_id:token:):</p> <ul> <li>Route: 604 (Watched Live Streaming Dates)</li> <li>Purpose: Retrieves the list of dates a user watched live streams for future features.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch the list of dates a user watched live streams, returning an array of Route604Response objects.</li> </ul> </li> <li> <p>getLastGiftSend(user_id:token:):</p> <ul> <li>Route: 605 (Last Gift Items)</li> <li>Purpose: Retrieves information about the last gift item sent by a user.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch details about the last gift item sent by a user, returning a Route605Response object.</li> </ul> </li> </ul>"},{"location":"technical/#considerations_1","title":"Considerations","text":"<ul> <li>Ensure proper error handling for network requests and API responses.</li> <li>Validate inputs (like tokens, IDs) before making API requests.</li> <li>Utilize async/await for asynchronous operations where supported to simplify concurrency.</li> <li>Test thoroughly across different network conditions and scenarios to ensure robustness.</li> </ul> <p>This documentation provides an overview of Webservice.swift, detailing its purpose, methods, routes, and considerations for effective usage in the \"Cheer Supports\" application.</p>"},{"location":"technical/#accountserviceviewmodel","title":"AccountServiceViewModel","text":""},{"location":"technical/#overview_2","title":"Overview","text":"<p>The <code>AccountServiceViewModel.swift</code> file serves as a view model in the \"Cheer Supports\" application, managing user authentication, data retrieval from APIs, and state management for user-related information. It utilizes Swift's Combine framework for reactive programming and asynchronous operations.</p>"},{"location":"technical/#class_2","title":"Class","text":"<p>The <code>AccountServiceViewModel</code> class encapsulates methods and properties to facilitate user authentication, data fetching, and management of user session state.</p>"},{"location":"technical/#properties_2","title":"Properties","text":"<ul> <li><code>isAuthenticated</code>: Tracks whether the user is authenticated.</li> <li><code>nick_name</code>: Stores the user's nickname.</li> <li><code>user_id</code>: Stores the user's ID.</li> <li><code>iconPath</code>: Stores the URL path for the user's avatar.</li> <li><code>email</code>: Stores the user's email address.</li> <li><code>password</code>: Stores the user's password.</li> <li><code>token</code>: Stores the authentication token for API requests.</li> <li><code>cheer</code>: Stores the user's cheer points.</li> <li><code>channel_id</code>: Stores the ID of the user's channel.</li> <li><code>follow</code>: Stores the count of users followed by the current user.</li> </ul>"},{"location":"technical/#methods_4","title":"Methods","text":"<ul> <li> <p><code>login(email:password:)</code>:</p> <ul> <li>Purpose: Initiates user login using provided email and password.</li> <li>Throws: Passes errors from <code>APIService().getLoginDatas</code> method.</li> <li>Description: Asynchronously fetches user authentication data from the server and updates view model properties upon successful login.</li> </ul> </li> <li> <p><code>authenticate(email:password:)</code>:</p> <ul> <li>Purpose: Attempts user authentication and returns a boolean indicating success.</li> <li>Throws: Passes errors from <code>login(email:password:)</code> method.</li> <li>Description: Calls <code>login(email:password:)</code> and handles authentication errors, returning the current authentication state.</li> </ul> </li> <li> <p><code>getAvatar()</code>:</p> <ul> <li>Purpose: Retrieves the user's avatar URL path.</li> <li>Throws: Handles errors from <code>APIService().getUserAvatar</code> method.</li> <li>Description: Asynchronously fetches and updates <code>iconPath</code> with the user's avatar URL.</li> </ul> </li> <li> <p><code>getChannelID()</code>:</p> <ul> <li>Purpose: Placeholder method for future implementation.</li> <li>Description: Intended for retrieving the user's channel ID, not yet implemented.</li> </ul> </li> <li> <p><code>logout()</code>:</p> <ul> <li>Purpose: Logs out the user by resetting authentication-related properties.</li> <li>Description: Resets <code>isAuthenticated</code>, <code>token</code>, <code>user_id</code>, <code>email</code>, <code>password</code>, and <code>iconPath</code> properties to empty or default values.</li> </ul> </li> <li> <p><code>checkUserCheerPoints()</code>:</p> <ul> <li>Purpose: Retrieves the user's current cheer points.</li> <li>Throws: Handles errors from <code>APIService().checkCurrentPoint</code> method.</li> <li>Description: Asynchronously fetches and updates <code>cheer</code> with the user's current cheer points.</li> </ul> </li> <li> <p><code>purchaseItem(price:quantity:productName:)</code>:</p> <ul> <li>Purpose: Initiates a purchase transaction for an item.</li> <li>Parameters: <code>price</code>, <code>quantity</code>, <code>productName</code> - Details of the item to purchase.</li> <li>Description: Asynchronously deducts cheer points from the user upon item purchase and updates <code>cheer</code> accordingly.</li> </ul> </li> <li> <p><code>getFollow()</code>:</p> <ul> <li>Purpose: Retrieves the count of users followed by the current user.</li> <li>Throws: Handles errors from <code>APIService().getFollowListCount</code> method.</li> <li>Description: Asynchronously fetches and updates <code>follow</code> with the count of users followed by the current user.</li> </ul> </li> <li> <p><code>isTodayLastStreamingDate()</code>:</p> <ul> <li>Purpose: Checks if the user streamed live today.</li> <li>Throws: Handles errors from <code>APIService().getLastStreaming</code> method.</li> <li>Description: Asynchronously checks if the user's last streaming date was today using <code>isToday</code> method.</li> </ul> </li> <li> <p><code>todayWatchStreams()</code>:</p> <ul> <li>Purpose: Checks if the user watched any live stream today.</li> <li>Throws: Handles errors from <code>APIService().getWatchedStreams</code> method.</li> <li>Description: Asynchronously checks if the user watched any live stream today using <code>isToday</code> method.</li> </ul> </li> <li> <p><code>lastGift()</code>:</p> <ul> <li>Purpose: Checks if the user sent a gift today.</li> <li>Throws: Handles errors from <code>APIService().getLastGiftSend</code> method.</li> <li>Description: Asynchronously checks if the user sent a gift today using <code>isToday</code> method.</li> </ul> </li> <li> <p><code>formattedDate(jsonDate:)</code>:</p> <ul> <li>Purpose: Converts a JSON-formatted date string to a <code>Date</code> object.</li> <li>Parameters: <code>jsonDate</code> - A date string in JSON format.</li> <li>Returns: A <code>Date</code> object parsed from the <code>jsonDate</code>.</li> </ul> </li> <li> <p><code>isToday(date:)</code>:</p> <ul> <li>Purpose: Checks if a given date is today.</li> <li>Parameters: <code>date</code> - The <code>Date</code> object to check.</li> <li>Returns: <code>true</code> if the date is today; otherwise, <code>false</code>.</li> </ul> </li> <li> <p><code>isStillLiveStreamActive()</code>:</p> <ul> <li>Purpose: Checks if the user's live stream is currently active.</li> <li>Throws: Handles errors from <code>APIService().getLastStreaming</code> method.</li> <li>Description: Asynchronously checks if the user's live stream is active today using <code>isToday</code> method.</li> </ul> </li> </ul>"},{"location":"technical/#usage-example","title":"Usage Example","text":"<p>Below is an example demonstrating how to use the <code>AccountServiceViewModel</code> class:</p> <pre><code>let viewModel = AccountServiceViewModel()\n\n// Example: Authenticate user\nasync {\n    do {\n        let isAuthenticated = try await viewModel.authenticate(email: \"user@example.com\", password: \"password\")\n        if isAuthenticated {\n            print(\"User is authenticated!\")\n            await viewModel.getAvatar()\n            await viewModel.checkUserCheerPoints()\n            let followCount = await viewModel.getFollow()\n            print(\"User is following \\(followCount) users.\")\n        } else {\n            print(\"Authentication failed.\")\n        }\n    } catch {\n        print(\"Error authenticating: \\(error)\")\n    }\n}\n</code></pre>"},{"location":"technical/#considerations_2","title":"Considerations","text":"<ul> <li>Ensure proper error handling for asynchronous operations and API requests.</li> <li>Use Combine framework for reactive updates to UI based on state changes.</li> <li>Validate inputs (like email and password) before making API requests.</li> <li>Test thoroughly under various network conditions and scenarios to ensure reliability.</li> </ul> <p>This documentation provides an overview of <code>AccountServiceViewModel.swift</code>, detailing its purpose, methods, properties, and considerations for effective usage in the \"Cheer Supports\" application.</p>"},{"location":"technical/#services","title":"Services","text":""},{"location":"technical/#databases","title":"Databases","text":""},{"location":"technical/#apis","title":"API's","text":""},{"location":"technical/#functions","title":"Functions","text":""},{"location":"technical/#other","title":"Other","text":""},{"location":"about/license/","title":"License","text":""},{"location":"about/release-notes/","title":"Release Notes","text":""}]}