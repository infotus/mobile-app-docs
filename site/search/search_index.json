{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#overview","title":"Overview","text":"<p>This documentation is for Cheer Supports app IOS version.</p> <p>This mobile application is the application of the Cheer Supports Website. It has been developed using the web-view method to ensure familiarity and display information about the events regularly and automatically. It also has additional features to cover the minimum features and requirements of a web-view app to publish in the Apple Store.</p> <p>Check more details about App Review Guidelines. </p> <p>Application features: </p> <ul> <li>In app login system</li> <li>In app chat system</li> <li>Daily tracking system </li> <li>Daily task system</li> <li>Rewards system</li> <li>Simple Leveling system</li> <li>In app usage only items</li> <li>In app purchase with Apple Pay</li> <li>Has notification system </li> <li>Has own point system for purchasing in app item</li> </ul> <p>Cheer Support App Repository</p>"},{"location":"#app-settings","title":"App Settings","text":"<p>Min IOS Deployment Target : 15.1</p> <p>Bundle Identifier : com.Kyi.Co.Ltd.Jp.Cheer-Supports</p> <p>Capabitilities : </p> <ul> <li>Background Modes [ Background fetch, Remote Notification, Background processing ]</li> <li>In-App Purchase</li> <li>Push Notification</li> </ul> <p>Operation System: MacOS</p> <p>IDE: Xcode</p> <p>Programming Language: Swift</p> <p>Framework: SwiftUI</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li> <p>Either use this step  Install GitHub Desktop software MacOS  Follow this steps for cloning repository.</p> </li> <li> <p>Or use command-line tools (terminal)</p> </li> </ul> <p><pre><code>git clone --single-branch --branch features/NewIOSVersion https://github.com/kyi-developers-organization/Cheer-Supports-Mobile-App.git\n</code></pre> This command line will clone ios xcode project only.</p>"},{"location":"#dependecies","title":"Dependecies","text":"<ul> <li> <p>Bottom Sheet -&gt; version 3.1.1 <pre><code>https://github.com/lucaszischka/BottomSheet.git\n</code></pre></p> </li> <li> <p>Firebase SDK -&gt; version 10.19.1 <pre><code>https://github.com/firebase/firebase-ios-sdk.git\n</code></pre></p> </li> <li> <p>SDWebImage SwiftUi -&gt; version 3.0.2 <pre><code>https://github.com/SDWebImage/SDWebImageSwiftUI.git\n</code></pre></p> </li> <li> <p>GoogleAPI Auth -&gt;  version 0.5.3 <pre><code>https://github.com/googleapis/google-auth-library-swift.git\n</code></pre></p> </li> </ul> <p>SPM Screenshot</p>"},{"location":"about/intro/","title":"Intro","text":""},{"location":"about/license/","title":"License","text":""},{"location":"about/release-notes/","title":"Release","text":""},{"location":"general/1layout/","title":"Project Layout","text":"<p>This is full navigation layout</p>"},{"location":"general/1layout/#home","title":"Home","text":"<p>Home is linked to Profile,  Chat, Cheer --&gt; Items and Settings views through buttons.</p> <p>Home page has 2 main stack view. First is contain webview, Second one is contain ui buttons. For better visualization about stack views check this image User has to be login both app and website login system otherwise streaming button will popup Signin view.  Users can register through website. </p>"},{"location":"general/1layout/#profile","title":"Profile","text":"<p>Profile is linked to Daily Tasks, Signin, Exp Purchase and Cheer through the buttons. </p> <p>This view divided 3 main stack views. User level section has Login button link to Sigin view. All user informations are saved Firebase DB --&gt; Users --&gt; UUID (uniqe id generated by Firebase).</p> <p>Reward Section contain only ui views.</p> <p>Level up section is has 3 buttons and linked to exp card purchase view, daily tasks view and Cheer purchase view respectively.  </p>"},{"location":"general/1layout/#daily-tasks","title":"Daily Tasks","text":"<p>Daily is only linked to Profile view. Divided 3 main stack views.  User Info section;  most of datas are retrieve from Firebase database, only cheer data value retrieve from AWS database. Daily Login section; contain UI view and related functions. Daily Missions section; Information about mission and button for collecting reward, buttons are will active when user finised the task otherwise will be inactive. Active buttons color is orange, inactive buttons color is gray. Every task has different shop points and exp point.</p>"},{"location":"general/1layout/#chat-room","title":"Chat Room","text":"<p>Chat is linked to Signin and Home through to butttons in Top section view. Chat section shows list of the message save in Firebase --&gt; Msgs documents. Bottom section; image picker and emoji view list hidden under plus \"+\" button and send button will hidden until user type any text or select any image(or emoji).  Top section and Section backgrounds are synchronized with ui button style. </p>"},{"location":"general/1layout/#cart","title":"Cart","text":"<p>Shop Cart has simple stack view tab buttons and view sections view section. View section shows cheer purchase view (default view) and app item purchase view. The shop cart view is linked only to the home view. Other content shows as a subview using the Bottom Sheet plugin. The toolbar contains shop points and the total cheer the user has. </p>"},{"location":"general/1layout/#cheer-purchase","title":"Cheer Purchase","text":"<p>There are 7 Cheer purchase products available.  500, 1000, 3000, 5000, 10000, 30000, and 50000 products are listed in view. If the user not logged in it will shows a notification. After successfulll purchase it will shows a notification.   </p>"},{"location":"general/1layout/#app-items-purchase","title":"App Items Purchase","text":"<p>There are 6 subview exist in App Item View. All subviews has 2 detents; medium and large.  Detents are dynamically adjusted the subview height. </p> <p>There are 3 purchase notification;</p> <ul> <li>Not enough Cheer or shopping Point</li> <li>Already have item</li> <li>Successfully purchased </li> </ul> <p>these notification are implemented in all app item purchase system.  </p>"},{"location":"general/1layout/#exp-purchase","title":"Exp Purchase","text":"<p>Simple a stack view with a purchase button. Detents set medium as default value. The maximum number of card purchases at a time has been determined as 99. </p>"},{"location":"general/1layout/#exp-multiply","title":"Exp Multiply","text":"<p>A view contain 3 stack views. Stack view contain information text and button. On button click it will show a confirmation dialog. </p>"},{"location":"general/1layout/#ui-style","title":"UI Style","text":"<p>There are 3 main stack views. These are button styles(3 items), background images(6 items) and backround color(6 items). All items can be purchased either with Cheer or Point. On Items click will show purchase options dialog. Every item group prices are different, button styles are each 500 Cheer or 500 Point, background images are each 200 Cheer or Point and background colors are each 50 Cheer or Point. Button Styles are set with a uniqe background images and background images and background color can be used in chat room background settings.</p>"},{"location":"general/1layout/#font-style","title":"Font Style","text":"<p>There are 2 main stack views.  These are font colors (6 items) and font styles(4 items). All items can be purchased either with Cheer or Point. On Items click will show purchase options dialog. Every items can be purchase  50 Cheer or 50 Point. Font style and font color can effect chat message text style. </p> <p>Note: Currently font style not effect logographic kanjis and furigana</p>"},{"location":"general/1layout/#emojis","title":"Emojis","text":"<p>There are 5 items using same view model within only stack view shows a list view. List items are clickable and show full list of the emoji group items. Items can be purhcase with cheer only and each emoji group is cost 500 cheer. On list clicked will show a popover. </p>"},{"location":"general/1layout/#animated-emojis","title":"Animated Emojis","text":"<p>There are 5 items using same view model within only stack view shows a list view. List items are clickable and show full list of the emoji group items. Items can be purhcase with cheer only and each emoji group is cost 1000 cheer. On list clicked will show a popover. </p>"},{"location":"general/1layout/#settings","title":"Settings","text":"<p>Settings is connected Home and Item views. Settings is divided for 3 sections. </p> <ol> <li>General</li> <li>Blocked User </li> <li>Others</li> </ol> <p>General section currently contain only owned items. Can find more detals in Items (Navigate to Items).</p> <p>Blocked Users has only list of the blocked users.</p> <p>Others section has 3 settings one of them share the application. the other is a toogle for showing level log in chat room view. When user reach level 2 it will automaticly will turn on. And last one is delete the account; this settings is required to publish the application in App Store. Delete the account is requests the deletion of data from both Firebase and AWS databases. </p>"},{"location":"general/1layout/#items","title":"Items","text":"<p>Item Lists Owned Items connect to Settings view. Divided 4 section with section header. All datas are saved in Owned Items array of users Firebase data collection. All settings effects only app view and styles, there is no effect on Cheer Supports webview also chat items cannot be use in streaming chat.</p> <ol> <li> <p>Background; This is for chat room message area background design settings. Onclick shows a menu, if the user has any color or image will show the submenu as Color or Images, and other default and cancel options available in the menu view list. \"Background\" text is clickable. For better performace all Horizontal Stack view should be button. </p> </li> <li> <p>Button; This is change set style for home button ui view style and also chat room top bar and bottom bar ui view. If user has any style it will shows a menu option with name.</p> </li> <li> <p>Font; There are 2 settings in this section font style and font color. Onclick shows a menu, if user has any font style or color will show the name in related menu. Current font styles are not effected furigana and kanjis. Need to add new styles for both Japanese and Chinese languages and Font Style Item view in shop should also changed based on language.</p> </li> <li> <p>Chat Items; Currently we have emojis and animated emojis items can be used in the app chat system. It is a dropdown list and shows a list of chat items purchased as text. List items are non-clickable.</p> </li> </ol>"},{"location":"general/2future/","title":"Future of App","text":"<p>There are a couple of features that need to be added and some that need to be updated for better app quality. It will be divided into 2 sections New Features and Updates Required Features. Couldn't put the app in stress tests. Based on my testing some features consume too much RAM for example animated emojis in the empty chat consume an average 30 mb when adding images or animated emojis it will rise to 100 mb. By following SDWebImageSwiftUI documentation instructions for cache managing decrease ram usage to 70 mb. Need additional measurements to further decrease for better performance. Some features need to be added (some of them are requested from the client). </p>"},{"location":"general/2future/#updates-required-features","title":"Updates Required Features","text":"<p>All of these suggestions are for better user experience and better app performance.  Feel free to implement solutions If you notice different issue(s) or have better solutions. Overall we are developers, and building the best products is our first task.</p> <ul> <li> <p>Webview is loading slowly. Excluding external reasons (non-app related reasons like wireless connection speed, connection signal quality, mobile phone CPU speed, RAM capacity of the phone, IOS version, etc.) there are multiple solutions to improve app quality. </p> <ol> <li>Webview app speed is directly linked to website performance. Therefore improve website load speed.</li> <li>By decreasing task requests before the app launch.</li> <li>Better user experiences add a loading image or some images can hide the loading process. Hide the image when webview is fully loaded.</li> </ol> </li> <li> <p>Animated Emojis consume too much RAM therefore certain views need attention. Global Chat, ShopView/Animated Emojis view are currently using SDWebImageSwiftui. </p> <ol> <li>Show limited messages in history of the messages.</li> <li>Play once or twice animated images. </li> <li>On tap gesture play selected emojis animation.</li> <li>Stop playing all animated emojis when the user saw the list.  </li> </ol> </li> <li> <p>Change the Full design of Shop Cart View. The current Bottom Sheet plugin response is not good enough.</p> <ol> <li>Change the bottom sheet view system to a navigation link system.</li> <li>Native sheet detents (medium and large) options are available IOS version 16.0 or later. Either change the minimum target version from 15.1 to 16.0 to create a dynamic detents system.  </li> </ol> </li> <li> <p>Add more emojis.</p> </li> <li> <p>Add more animated emojis.</p> </li> <li> <p>Add more UI styles. Current font styles are working on romaji letters, add more font styles, especially for furigana and kanji. </p> </li> <li> <p>Update settings UI view with better design.</p> </li> <li> <p>Replace the webview system with an application-specific system with new ui design and with synchronized current website database.</p> </li> </ul>"},{"location":"general/2future/#new-features","title":"New Features","text":"<p>Before explaining new features there are a few points that need to mention. Before started developing the mobile application there was a conversation about changing Cheer Support web content. At first idea was a full renewal of the web content and then middle of development it is changed to re-design. Those are 2 different approaches. Because of the uncertainty mobile app structure becomes more restricted.</p> <p>Renewal is changing all structures, API routes, UI design, and database of the web content. Anything related back-end will directly affect the mobile application.  </p> <p>Redesigning, on the other hand, affects the user's view of web content. While this approach has a potential impact on the backend, it will be limited and, therefore on impact the mobile app also limited. </p> <p>Members who could work were limited. I worked with only one graphic designer on this project. He creates most of the images, emojis and animated emojis, the rest is done solely by me. There was only one front-end developer in the web content, but she was working as a full-stack developer. So working with her also was out of the option.</p> <p>There were requests from the CEO and client. Most of them are already done and there are 2 features left to implement for finishing the app. There are preparations to be made before adding these features, as well as the completion of the redesign of the website and the completion of the back-end related new design.</p> <ul> <li> <p>At the time of writing this document, there were 7 WebGL applications in the web content. All WebGL applications are developed with a cross-platform called Unity Game Engine. These applications do not work on mobile browsers and the CEO requested that these applications be available on mobile devices. To achieve this those are the preparations required;</p> <ol> <li>Convert to WebGL application to IOS application</li> <li>Optimized the app for mobile (for example occlusion culling, lightmap, decrease the RAM usage ...)</li> <li>Add UI and controller system for mobile app use</li> <li>Decrease the size of the app (There is a maximum size limit to upload the App Store)</li> </ol> </li> </ul> <p>The above steps should be followed for 6 applications. WebGL applications called Hoshiyomi are already published on the App Store and Play Store.</p> <ul> <li> <p>Add the Augmented Reality future with body and face tracking to the live-streaming feature. </p> </li> <li> <p>Add noice cancelling feature to live-streaming.</p> </li> </ul>"},{"location":"technical/0tech-intro/","title":"Introduction","text":"<ol> <li> <p>This application developed on IOS 15.1 - 17.4 - using Swift / Objective-C - with SwiftUI framework</p> </li> <li> <p>This applicaiton is intended for use smartphone only, in a portrait orientation.</p> </li> <li> <p>JSON requests are used to handle the communication between the app and servers.</p> </li> <li> <p>This application works only in online mode.</p> </li> <li> <p>Push notifications are handled by Firebase.</p> </li> <li> <p>Real-time messages are handled by Firebase.</p> </li> <li> <p>User Daily Login informations are handled by Firebase, all information mobile application usage related only.</p> </li> <li> <p>New User registration can be done webview only. </p> </li> <li> <p>Webview datas are handled by AWS</p> </li> <li> <p>In app purchase system is implemented the mobile application only</p> </li> </ol>"},{"location":"technical/1webview/","title":"WebView","text":""},{"location":"technical/1webview/#overview","title":"Overview","text":"<p>To show that Cheer Supports web content on mobile I used an open-source web browser engine called Webkit. WebKit is a browser engine primarily used in Apple's Safari web browser, as well as all web browsers on iOS and iPadOS. Cheer Supports web content is changing frequently and to keep up with the web content updates webview was the best choice. All scripts related webview is separeated from the others and they under 'Webservices' folder. Folder contain \"WebView\", \"WebViewModel\", \"APIService\" and AccountServiceViewModel script files. </p> <p>The WebView struct is a SwiftUI component designed to display web content using WKWebView, which is part of the WebKit framework. It integrates into SwiftUI views to render web pages specified by a URL and provides functionality for observing URL changes, handling navigation, and interacting with JavaScript.</p>"},{"location":"technical/1webview/#struct-webview","title":"Struct: WebView","text":"<p>The WebView struct conforms to UIViewRepresentable, making it compatible with SwiftUI's view hierarchy. Properties</p> <ul> <li>url: A String property representing the main URL to be loaded initially.</li> <li>webVM: An instance of WebViewModel used to manage state and interactions with the web view.</li> </ul>"},{"location":"technical/1webview/#methods","title":"Methods","text":"<ul> <li> <p>makeUIView: Initializes and configures the WKWebView instance. Sets up configuration for media playback and JavaScript interaction permissions. Observes URL changes and updates the webVM's current_url property.</p> </li> <li> <p>updateUIView: Updates the WKWebView instance with a new URL when the url property changes.</p> </li> <li> <p>makeCoordinator: Creates and returns an instance of the Coordinator class, which acts as the delegate for the WKWebView and handles navigation events.</p> </li> </ul>"},{"location":"technical/1webview/#class-coordinator","title":"Class: Coordinator","text":"<p>The Coordinator class manages interactions and events within the WKWebView instance. Properties</p> <ul> <li>parent: A reference to the parent WebView instance.</li> <li>observer: An optional NSKeyValueObservation instance to observe URL changes in the web view.</li> </ul>"},{"location":"technical/1webview/#methods_1","title":"Methods","text":"<ul> <li> <p>webView(_:didFail:withError:): Delegate method called when navigation to a URL fails. Prints the error message.</p> </li> <li> <p>webView(_:didFinish:): Delegate method called when web view finishes loading a URL. Prints a success message.</p> </li> <li> <p>webView(_:createWebViewWith:for:windowFeatures:): Delegate method to handle creating a new web view for navigation actions that target a new frame.</p> </li> <li> <p>webView(_:didReceiveServerRedirectForProvisionalNavigation:): Delegate method called when the web view receives a server redirect during navigation. Prints the redirected URL.</p> </li> </ul>"},{"location":"technical/1webview/#extension-wkwebview","title":"Extension: WKWebView","text":"<p>An extension on WKWebView provides additional functionality to create JSON data from a dictionary. Methods</p> <ul> <li>createJsonData(for:): Converts a dictionary [String:Any] into a JSON string, removing unnecessary whitespace and newline characters.</li> </ul>"},{"location":"technical/1webview/#usage","title":"Usage","text":"<p>To use the WebView component in a SwiftUI view, initialize it with a url and webVM instance. Example usage: <pre><code>struct ContentView: View {\n    @StateObject private var webVM = WebViewModel()\n\n    var body: some View {\n        WebView(url: \"https://www.example.com\", webVM: webVM)\n            .onAppear {\n                // Additional setup when the web view appears\n            }\n    }\n}\n</code></pre></p> <p>Considerations:</p> <ul> <li>Ensure proper handling of JavaScript interactions and permissions based on application requirements.</li> <li>Monitor for potential memory leaks when using observers and delegates.</li> <li>Test thoroughly across different web content to ensure compatibility and responsiveness.</li> </ul> <p>This documentation outlines the structure, functionality, and usage considerations for integrating a web view within a SwiftUI application using the WebView struct.</p>"},{"location":"technical/1webview/#webviewmodel","title":"WebViewModel","text":""},{"location":"technical/1webview/#overview_1","title":"Overview","text":"<p>The WebViewModel.swift file contains the WebViewModel class, which serves as a bridge between SwiftUI components and the WKWebView for managing web content interactions. It includes methods for reloading, navigating, and interacting with local storage within the web view.</p>"},{"location":"technical/1webview/#class","title":"Class","text":"<p>The WebViewModel class extends NSObject and conforms to ObservableObject and WKNavigationDelegate, facilitating communication between SwiftUI views and the web view.</p>"},{"location":"technical/1webview/#properties","title":"Properties","text":"<ul> <li>current_url: A @Published property that stores the current URL loaded in the web view.</li> <li>webView: An optional WKWebView instance. Setting this property assigns the navigation delegate to self.</li> </ul>"},{"location":"technical/1webview/#methods_2","title":"Methods","text":"<ul> <li> <p>reload(): Reloads the current web page.</p> </li> <li> <p>goBack(): Navigates back to the previous web page.</p> </li> <li> <p>getCurrentURL(): Retrieves the URL of the current web page.</p> </li> <li> <p>setLocalStorage(name: id: token: ): Stores user data in the browser's local storage using JavaScript. Converts a dictionary to JSON format and injects it into the local storage.</p> </li> <li> <p>getLocalStorage(): Retrieves data from the browser's local storage using JavaScript.</p> </li> <li> <p>clearLocalStorage(): Clears all data from the browser's local storage using JavaScript.</p> </li> </ul>"},{"location":"technical/1webview/#delegate-methods","title":"Delegate Methods","text":"<ul> <li> <p>webView(_:didFail:withError:): Delegate method called when web view navigation fails. Prints the error message if navigation fails.</p> </li> <li> <p>webView(_:didFinish:): Delegate method called when web view finishes loading a URL. Handles necessary actions upon successful navigation.</p> </li> </ul>"},{"location":"technical/1webview/#usage_1","title":"Usage","text":"<p>To use WebViewModel in a SwiftUI application, instantiate it and use its methods to interact with the embedded WKWebView.</p> <p>Example: </p> <pre><code>struct ContentView: View {\n    @StateObject private var webVM = WebViewModel()\n\n    var body: some View {\n        VStack {\n            Text(\"Current URL: \\(webVM.current_url)\")\n            Button(\"Reload\") {\n                webVM.reload()\n            }\n            Button(\"Go Back\") {\n                webVM.goBack()\n            }\n            Button(\"Get Local Storage\") {\n                webVM.getLocalStorage()\n            }\n        }\n        .onAppear {\n            // Setup initial web view configuration\n            let webView = WKWebView()\n            webVM.webView = webView\n\n            // Load initial URL\n            let initialURL = URL(string: \"https://www.example.com\")!\n            webView.load(URLRequest(url: initialURL))\n        }\n    }\n}\n</code></pre>"},{"location":"technical/1webview/#considerations","title":"Considerations","text":"<ul> <li>Ensure proper handling of optional values when accessing webView property.</li> <li>Manage JavaScript interactions cautiously, especially with sensitive user data stored in local storage.</li> <li>Test thoroughly across different web scenarios to verify functionality and error handling.</li> </ul> <p>This documentation provides an overview of WebViewModel.swift, describing its purpose, properties, methods, and usage within a SwiftUI context. It outlines how to interact with web views and manage local storage effectively.</p>"},{"location":"technical/1webview/#apiservice","title":"APIService","text":""},{"location":"technical/1webview/#overview_2","title":"Overview","text":"<p>The Webservice.swift file encapsulates various API request functions and handles corresponding responses for the \"Cheer Supports\" application. It uses Swift's URLSession and Combine framework for asynchronous networking tasks, ensuring efficient communication with the backend services.</p>"},{"location":"technical/1webview/#class_1","title":"Class","text":"<p>The APIService class contains methods for making API requests to different endpoints, processing responses, and handling errors. Each method corresponds to a specific API route within the application.</p>"},{"location":"technical/1webview/#properties_1","title":"Properties","text":"<p>None.</p>"},{"location":"technical/1webview/#methods_3","title":"Methods","text":"<ul> <li> <p>getUserAvatar(token:):</p> <ul> <li>Route: 195 (User information)</li> <li>Purpose: Retrieves the avatar URL for a user.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Fetches user avatar details from the server using HTTP GET request and returns the avatar URL as a String.</li> </ul> </li> <li> <p>getUserProfile(token:):</p> <ul> <li>Route: 129 (User profile information)</li> <li>Purpose: Retrieves user profile information, specifically live streaming status.</li> <li>Throws: PathError.noData, PathError.invalidUrl</li> <li>Description: Sends a GET request to fetch user profile data and returns an array of Route129Response objects.</li> </ul> </li> <li> <p>getLoginDatas(email:password:completion:):</p> <ul> <li>Route: 100 (Login)</li> <li>Purpose: Performs user login and retrieves user ID, token, and nickname upon successful authentication.</li> <li>Throws: No direct throws, uses completion handler for AuthenticationError cases.</li> <li>Description: Sends a POST request with login credentials, handles the response asynchronously using URLSession, and provides results through a completion handler.</li> </ul> </li> <li> <p>checkCurrentPoint(user_id:token:):</p> <ul> <li>Route: 198 (Get user current points)</li> <li>Purpose: Retrieves the current cheer coins for a user.</li> <li>Throws: AuthenticationError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch user's current cheer coins based on user ID and token, returning the amount as a String.</li> </ul> </li> <li> <p>sendEncodedData(encoded_key:token:completion:):</p> <ul> <li>Route: 601 (Decrypt the purchase key)</li> <li>Purpose: Decrypts a purchase key for in-app payment.</li> <li>Throws: PurchaseError.invalidUrl, PurchaseError.invalidKey</li> <li>Description: Sends a POST request to decrypt an encoded key using a token, handling the response asynchronously through a completion handler.</li> </ul> </li> <li> <p>sendCheerDeductionInformations(user_id:token:quantity:price:platform:item_id:completion:):</p> <ul> <li>Route: 602 (Update the Cheer)</li> <li>Purpose: Deducts cheer points upon item purchase in the application.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a POST request to update cheer points deduction, handling the response asynchronously through a completion handler.</li> </ul> </li> <li> <p>deleteAccountRequest(user_id:token:):</p> <ul> <li>Route: 132 (Account deletion request)</li> <li>Purpose: Sends a request to delete a user account.</li> <li>Throws: No direct throws, prints error message for invalid API URL.</li> <li>Description: Sends a POST request to initiate an account deletion request using user ID and token.</li> </ul> </li> <li> <p>getFollowListCount(user_id:token:):</p> <ul> <li>Route: 196 (Follow list count)</li> <li>Purpose: Retrieves the count of users a particular user is following.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch the count of users followed by a specified user, returning a Route196Response object.</li> </ul> </li> <li> <p>getLastStreaming(user_id:token:):</p> <ul> <li>Route: 603 (Last Streaming Date)</li> <li>Purpose: Retrieves the last streaming date for mission reward calculations.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch the last streaming date of a user based on user ID and token, returning a Route603Response object.</li> </ul> </li> <li> <p>getWatchedStreams(user_id:token:):</p> <ul> <li>Route: 604 (Watched Live Streaming Dates)</li> <li>Purpose: Retrieves the list of dates a user watched live streams for future features.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch the list of dates a user watched live streams, returning an array of Route604Response objects.</li> </ul> </li> <li> <p>getLastGiftSend(user_id:token:):</p> <ul> <li>Route: 605 (Last Gift Items)</li> <li>Purpose: Retrieves information about the last gift item sent by a user.</li> <li>Throws: PathError.custom, PathError.noData</li> <li>Description: Sends a GET request to fetch details about the last gift item sent by a user, returning a Route605Response object.</li> </ul> </li> </ul>"},{"location":"technical/1webview/#considerations_1","title":"Considerations","text":"<ul> <li>Ensure proper error handling for network requests and API responses.</li> <li>Validate inputs (like tokens, IDs) before making API requests.</li> <li>Utilize async/await for asynchronous operations where supported to simplify concurrency.</li> <li>Test thoroughly across different network conditions and scenarios to ensure robustness.</li> </ul> <p>This documentation provides an overview of Webservice.swift, detailing its purpose, methods, routes, and considerations for effective usage in the \"Cheer Supports\" application.</p>"},{"location":"technical/1webview/#accountserviceviewmodel","title":"AccountServiceViewModel","text":""},{"location":"technical/1webview/#overview_3","title":"Overview","text":"<p>The <code>AccountServiceViewModel.swift</code> file serves as a view model in the \"Cheer Supports\" application, managing user authentication, data retrieval from APIs, and state management for user-related information. It utilizes Swift's Combine framework for reactive programming and asynchronous operations.</p>"},{"location":"technical/1webview/#class_2","title":"Class","text":"<p>The <code>AccountServiceViewModel</code> class encapsulates methods and properties to facilitate user authentication, data fetching, and management of user session state.</p>"},{"location":"technical/1webview/#properties_2","title":"Properties","text":"<ul> <li><code>isAuthenticated</code>: Tracks whether the user is authenticated.</li> <li><code>nick_name</code>: Stores the user's nickname.</li> <li><code>user_id</code>: Stores the user's ID.</li> <li><code>iconPath</code>: Stores the URL path for the user's avatar.</li> <li><code>email</code>: Stores the user's email address.</li> <li><code>password</code>: Stores the user's password.</li> <li><code>token</code>: Stores the authentication token for API requests.</li> <li><code>cheer</code>: Stores the user's cheer points.</li> <li><code>channel_id</code>: Stores the ID of the user's channel.</li> <li><code>follow</code>: Stores the count of users followed by the current user.</li> </ul>"},{"location":"technical/1webview/#methods_4","title":"Methods","text":"<ul> <li> <p><code>login(email:password:)</code>:</p> <ul> <li>Purpose: Initiates user login using provided email and password.</li> <li>Throws: Passes errors from <code>APIService().getLoginDatas</code> method.</li> <li>Description: Asynchronously fetches user authentication data from the server and updates view model properties upon successful login.</li> </ul> </li> <li> <p><code>authenticate(email:password:)</code>:</p> <ul> <li>Purpose: Attempts user authentication and returns a boolean indicating success.</li> <li>Throws: Passes errors from <code>login(email:password:)</code> method.</li> <li>Description: Calls <code>login(email:password:)</code> and handles authentication errors, returning the current authentication state.</li> </ul> </li> <li> <p><code>getAvatar()</code>:</p> <ul> <li>Purpose: Retrieves the user's avatar URL path.</li> <li>Throws: Handles errors from <code>APIService().getUserAvatar</code> method.</li> <li>Description: Asynchronously fetches and updates <code>iconPath</code> with the user's avatar URL.</li> </ul> </li> <li> <p><code>getChannelID()</code>:</p> <ul> <li>Purpose: Placeholder method for future implementation.</li> <li>Description: Intended for retrieving the user's channel ID, not yet implemented.</li> </ul> </li> <li> <p><code>logout()</code>:</p> <ul> <li>Purpose: Logs out the user by resetting authentication-related properties.</li> <li>Description: Resets <code>isAuthenticated</code>, <code>token</code>, <code>user_id</code>, <code>email</code>, <code>password</code>, and <code>iconPath</code> properties to empty or default values.</li> </ul> </li> <li> <p><code>checkUserCheerPoints()</code>:</p> <ul> <li>Purpose: Retrieves the user's current cheer points.</li> <li>Throws: Handles errors from <code>APIService().checkCurrentPoint</code> method.</li> <li>Description: Asynchronously fetches and updates <code>cheer</code> with the user's current cheer points.</li> </ul> </li> <li> <p><code>purchaseItem(price:quantity:productName:)</code>:</p> <ul> <li>Purpose: Initiates a purchase transaction for an item.</li> <li>Parameters: <code>price</code>, <code>quantity</code>, <code>productName</code> - Details of the item to purchase.</li> <li>Description: Asynchronously deducts cheer points from the user upon item purchase and updates <code>cheer</code> accordingly.</li> </ul> </li> <li> <p><code>getFollow()</code>:</p> <ul> <li>Purpose: Retrieves the count of users followed by the current user.</li> <li>Throws: Handles errors from <code>APIService().getFollowListCount</code> method.</li> <li>Description: Asynchronously fetches and updates <code>follow</code> with the count of users followed by the current user.</li> </ul> </li> <li> <p><code>isTodayLastStreamingDate()</code>:</p> <ul> <li>Purpose: Checks if the user streamed live today.</li> <li>Throws: Handles errors from <code>APIService().getLastStreaming</code> method.</li> <li>Description: Asynchronously checks if the user's last streaming date was today using <code>isToday</code> method.</li> </ul> </li> <li> <p><code>todayWatchStreams()</code>:</p> <ul> <li>Purpose: Checks if the user watched any live stream today.</li> <li>Throws: Handles errors from <code>APIService().getWatchedStreams</code> method.</li> <li>Description: Asynchronously checks if the user watched any live stream today using <code>isToday</code> method.</li> </ul> </li> <li> <p><code>lastGift()</code>:</p> <ul> <li>Purpose: Checks if the user sent a gift today.</li> <li>Throws: Handles errors from <code>APIService().getLastGiftSend</code> method.</li> <li>Description: Asynchronously checks if the user sent a gift today using <code>isToday</code> method.</li> </ul> </li> <li> <p><code>formattedDate(jsonDate:)</code>:</p> <ul> <li>Purpose: Converts a JSON-formatted date string to a <code>Date</code> object.</li> <li>Parameters: <code>jsonDate</code> - A date string in JSON format.</li> <li>Returns: A <code>Date</code> object parsed from the <code>jsonDate</code>.</li> </ul> </li> <li> <p><code>isToday(date:)</code>:</p> <ul> <li>Purpose: Checks if a given date is today.</li> <li>Parameters: <code>date</code> - The <code>Date</code> object to check.</li> <li>Returns: <code>true</code> if the date is today; otherwise, <code>false</code>.</li> </ul> </li> <li> <p><code>isStillLiveStreamActive()</code>:</p> <ul> <li>Purpose: Checks if the user's live stream is currently active.</li> <li>Throws: Handles errors from <code>APIService().getLastStreaming</code> method.</li> <li>Description: Asynchronously checks if the user's live stream is active today using <code>isToday</code> method.</li> </ul> </li> </ul>"},{"location":"technical/1webview/#usage-example","title":"Usage Example","text":"<p>Below is an example demonstrating how to use the <code>AccountServiceViewModel</code> class:</p> <pre><code>let viewModel = AccountServiceViewModel()\n\n// Example: Authenticate user\nasync {\n    do {\n        let isAuthenticated = try await viewModel.authenticate(email: \"user@example.com\", password: \"password\")\n        if isAuthenticated {\n            print(\"User is authenticated!\")\n            await viewModel.getAvatar()\n            await viewModel.checkUserCheerPoints()\n            let followCount = await viewModel.getFollow()\n            print(\"User is following \\(followCount) users.\")\n        } else {\n            print(\"Authentication failed.\")\n        }\n    } catch {\n        print(\"Error authenticating: \\(error)\")\n    }\n}\n</code></pre>"},{"location":"technical/1webview/#considerations_2","title":"Considerations","text":"<ul> <li>Ensure proper error handling for asynchronous operations and API requests.</li> <li>Use Combine framework for reactive updates to UI based on state changes.</li> <li>Validate inputs (like email and password) before making API requests.</li> <li>Test thoroughly under various network conditions and scenarios to ensure reliability.</li> </ul> <p>This documentation provides an overview of <code>AccountServiceViewModel.swift</code>, detailing its purpose, methods, properties, and considerations for effective usage in the \"Cheer Supports\" application.</p>"},{"location":"technical/3databases/","title":"Databases","text":""},{"location":"technical/4api/","title":"API's Documentation","text":""},{"location":"technical/5func/","title":"Functions","text":""},{"location":"technical/6other/","title":"Other","text":""},{"location":"technical/Services/2services/","title":"Intro","text":""},{"location":"technical/Services/2services/#overview","title":"Overview","text":"<p>In addition to the website services, three additional services have been integrated into the application to comply with specific App Store Review Guidelines. The Login Reward Service and Chat Service were implemented to meet the requirements of App Store Review Guideline 4.2, while the third service aligns with App Store Review Guideline 3.1.1.</p> <p>User-related information is managed by Firebase, utilizing four main components: Authentication, Cloud Messaging, Storage, and Cloud Firestore.</p> <p>Please note that the information provided here is for preview purposes only. Real credentials and details will be updated once the repository becomes private.</p>"},{"location":"technical/Services/2services/#credentials","title":"Credentials","text":"<ul> <li>Email: [Admin Email]</li> <li>Password: [Admin Password]</li> </ul>"},{"location":"technical/Services/2services/#project-details","title":"Project Details","text":"<ul> <li>Project Name: Cheer Supports Iphone only</li> <li>Project ID: cheer-supports-iphone</li> <li>Project Number: 12345676789 (fake)</li> <li>Web API Key: A2039475304ut9euwr40ruw9refu0e9urf (fake)</li> <li>Public Facing Name: Cheer Supports</li> <li>Support Email: test@test.com (fake)</li> </ul>"},{"location":"technical/Services/2services/#firebase-sdk-setup-and-configuration","title":"Firebase SDK Setup and Configuration","text":"<ul> <li>App ID: 1:299237459823454093868794586 (fake)</li> <li>Encoded App ID: app-1-299237459823454093868794586 (fake)</li> <li>App Nickname: Cheer Supports</li> <li>Bundle ID: com.cheer-supports (fake)</li> <li>App Store ID: 54908673459 (fake)</li> <li>Team ID: J8973U98w4u (fake)</li> </ul>"},{"location":"technical/Services/2services/#cloud-messaging","title":"Cloud Messaging","text":"<p>Firebase Cloud Messaging API V1 is utilized for notification services.</p> <ul> <li>Sender ID: 439280572 (fake)</li> <li>Service Account: JSON will be added later</li> </ul>"},{"location":"technical/Services/2services/#apns-setup","title":"APNs Setup","text":"<p>For proper notification functionality, ensure the following:</p> <ul> <li>APNs Auth Key and Production APNs Certificate files are shared separately. These files are crucial for notification services.</li> </ul>"},{"location":"technical/Services/2services/#legacy-api-deprecation","title":"Legacy API Deprecation","text":"<p>Web Push Certificate is currently used for testing purposes only and was supported by Cloud Messaging API (Legacy) until July 22, 2024. Due to security concerns, Google has announced the shutdown of this API, which will be replaced with Firebase Cloud Messaging API V1. The new API utilizes OAuth 2.0 authentication. For more details, refer to here.</p>"},{"location":"technical/Services/2services/#access-and-configuration","title":"Access and Configuration","text":"<p>Access to the cloud messaging service requires a Google API access token, obtainable through the service account. The management of this token and the notification service is handled by 'NotificationManager.swift'. For more information about the manager, please check here.</p>"},{"location":"technical/Services/IAP/iap/","title":"In App Purchase","text":""},{"location":"technical/Services/aws/26awsintro/","title":"Overview","text":""},{"location":"technical/Services/aws/26awsintro/#user-information-management","title":"User Information Management","text":"<p>All user data operations are managed and stored within the <code>AccountServiceViewModel.swift</code> script. This component handles the storage, retrieval, and manipulation of user information throughout the application lifecycle.</p>"},{"location":"technical/Services/aws/26awsintro/#api-integration","title":"API Integration","text":"<p>API requests are handled by the <code>APIService.swift</code> script. This module encapsulates all interactions with external APIs, facilitating seamless data exchange and integration with remote services.</p>"},{"location":"technical/Services/aws/26awsintro/#details","title":"Details","text":"<ul> <li> <p>WebView Section: Functions related to WebView interactions can be found within the respective section of the codebase. These functions manage interactions with the application's web-based content, ensuring synchronization with internal data handling mechanisms.</p> </li> <li> <p>Database Section: For a detailed understanding of the application's data structure and interaction with databases, refer to the database section. This section outlines the schema and relationships used within the application's data storage solutions.</p> </li> </ul> <p>This documentation provides a structured overview of where to find and how to utilize functionalities related to user information management, API integration, WebView interactions, and database interactions within the application's technical framework.</p>"},{"location":"technical/Services/aws/27authentication/","title":"Authentication","text":""},{"location":"technical/Services/aws/27authentication/#api-requests-for-web-content-authentication","title":"API Requests for Web Content Authentication","text":""},{"location":"technical/Services/aws/27authentication/#overview","title":"Overview","text":"<p>To authenticate web content access, the application utilizes two API requests. These requests are implemented in <code>APIService.swift</code> and <code>SignInViewModel.swift</code>, each serving distinct purposes in the authentication process.</p>"},{"location":"technical/Services/aws/27authentication/#api-request-functions","title":"API Request Functions","text":""},{"location":"technical/Services/aws/27authentication/#apiserviceswift","title":"<code>APIService.swift</code>","text":"<p>The <code>APIService.swift</code> script manages API interactions related to web content authentication. Specifically, the <code>getLoginData()</code> function within this script handles authentication by retrieving necessary data from external sources. Additionally, <code>APIService.swift</code> manages the storage and processing of user-related parameters essential for authentication.</p>"},{"location":"technical/Services/aws/27authentication/#signinviewmodelswift","title":"<code>SignInViewModel.swift</code>","text":"<p>In contrast, <code>SignInViewModel.swift</code> focuses solely on authentication verification. It utilizes an API request to verify user credentials and validate access to web content. This component does not handle parameter storage but rather concentrates on the authentication process itself.</p>"},{"location":"technical/Services/aws/27authentication/#functional-roles","title":"Functional Roles","text":"<ul> <li>APIService.swift: Responsible for retrieving authentication data and managing user parameters required for authentication purposes.</li> <li>SignInViewModel.swift: Concentrates on user authentication verification, ensuring secure access to web content through API interactions.</li> </ul>"},{"location":"technical/Services/aws/27authentication/#integration-details","title":"Integration Details","text":"<ul> <li>Usage: Utilize <code>APIService.swift</code> for fetching login data and managing user parameters. Refer to <code>SignInViewModel.swift</code> for executing authentication checks and validating user access based on retrieved credentials.</li> </ul>"},{"location":"technical/Services/aws/27authentication/#signinviewmodel","title":"SignInViewModel","text":""},{"location":"technical/Services/aws/27authentication/#overview_1","title":"Overview","text":"<p>The <code>SignInViewModel</code> class manages the user interface and network interactions for the sign-in process in the Cheer Supports application. This documentation provides an overview of its structure, functionality, and usage.</p>"},{"location":"technical/Services/aws/27authentication/#class-structure","title":"Class Structure","text":""},{"location":"technical/Services/aws/27authentication/#explanation","title":"Explanation","text":""},{"location":"technical/Services/aws/27authentication/#properties","title":"Properties","text":"<ul> <li> <p>@Published variables: These properties are used for reactive UI updates, allowing the view to update automatically based on changes to <code>email</code>, <code>password</code>, <code>hasError</code>, and <code>isSigningIn</code>.</p> </li> <li> <p>canSignIn: This computed property checks if both <code>email</code> and <code>password</code> are not empty, enabling the sign-in button or action.</p> </li> </ul>"},{"location":"technical/Services/aws/27authentication/#methods","title":"Methods","text":"<ul> <li>signIn(): Initiates the sign-in process by constructing a <code>URLRequest</code> to the API endpoint (<code>https://api.cheer-supports.com/api/v1/liver/login</code>). It performs Basic Authentication using the provided <code>email</code> and <code>password</code>. Upon receiving the response, it checks for errors and decodes the JSON response using <code>JSONDecoder</code>. If successful, it prints the <code>accessToken</code> from <code>SignInResponse</code>.</li> </ul>"},{"location":"technical/Services/aws/27authentication/#network-request-handling","title":"Network Request Handling","text":"<ul> <li>The network request (<code>URLSession.shared.dataTask</code>) is performed asynchronously. Upon completion:</li> <li>If there's an <code>error</code> during the request or the HTTP status code is not 200, <code>hasError</code> is set to <code>true</code>.</li> <li>If the response data is received successfully, it attempts to decode it into the <code>SignInResponse</code> structure. Errors during decoding also set <code>hasError</code> to <code>true</code>.</li> </ul>"},{"location":"technical/Services/aws/27authentication/#error-handling","title":"Error Handling","text":"<ul> <li>Errors are handled both at the network request level and during JSON decoding. They are printed to the console for debugging purposes and set <code>hasError</code> to <code>true</code> to indicate a failed sign-in attempt.</li> </ul>"},{"location":"technical/Services/aws/27authentication/#usage","title":"Usage","text":""},{"location":"technical/Services/aws/27authentication/#integration-in-swiftui-views","title":"Integration in SwiftUI Views","text":"<p>You can integrate <code>SignInViewModel</code> into your SwiftUI views as follows:</p> <pre><code>struct SignInView: View {\n    @StateObject private var signInViewModel = SignInViewModel()\n\n    var body: some View {\n        VStack {\n            TextField(\"Email\", text: $signInViewModel.email)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n\n            SecureField(\"Password\", text: $signInViewModel.password)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .padding()\n\n            Button(action: {\n                signInViewModel.signIn()\n            }) {\n                Text(\"Sign In\")\n            }\n            .disabled(!signInViewModel.canSignIn)\n            .padding()\n\n            if signInViewModel.hasError {\n                Text(\"Sign In Failed\")\n                    .foregroundColor(.red)\n            }\n\n            if signInViewModel.isSigningIn {\n                ProgressView()\n            }\n        }\n        .padding()\n    }\n}\n</code></pre>"},{"location":"technical/Services/aws/27authentication/#example","title":"Example","text":"<p>In your SwiftUI view, bind the text fields to <code>email</code> and <code>password</code>, enable the sign-in button based on <code>canSignIn</code>, and handle UI updates based on <code>hasError</code> and <code>isSigningIn</code>.</p>"},{"location":"technical/Services/aws/27authentication/#conclusion","title":"Conclusion","text":"<p>The <code>SignInViewModel</code> class encapsulates the logic for signing in users through an API endpoint using Basic Authentication. It provides reactive properties for seamless integration with SwiftUI views, ensuring a smooth user experience while handling network requests and error conditions effectively.</p> <p>This documentation guides you through integrating and understanding the <code>SignInViewModel</code> class within your SwiftUI-based application for managing user sign-in functionality.</p>"},{"location":"technical/Services/chat/chat/","title":"Global Chat","text":""},{"location":"technical/Services/daily/daily/","title":"Daily Login Tracking","text":""},{"location":"technical/Services/firebase/21firebaseintro/","title":"Overview","text":"<p>Here's an improved version for technical documentation:</p> <p>We are utilizing Firebase services under the free tier plan, which comes with certain usage limitations. To stay within these limits, it is essential to implement several measures. For instance, optimizing image and data sizes to reduce consumption, minimizing daily request volumes, and so on.</p>"},{"location":"technical/Services/firebase/21firebaseintro/#firebasemanager-class","title":"FirebaseManager Class","text":"<p>The <code>FirebaseManager</code> class provides a centralized management of Firebase services for authentication, cloud storage, real-time database, and Firestore within an iOS application built using SwiftUI. This documentation explains the structure of the class, its initialization, and the Firebase services it manages.</p>"},{"location":"technical/Services/firebase/21firebaseintro/#dependencies","title":"Dependencies","text":"<p>To use <code>FirebaseManager</code>, ensure the following Firebase modules are integrated into your project using CocoaPods or manually: - Firebase - FirebaseDatabase - FirebaseFirestore - FirebaseStorage</p>"},{"location":"technical/Services/firebase/21firebaseintro/#class-structure","title":"Class Structure","text":""},{"location":"technical/Services/firebase/21firebaseintro/#properties","title":"Properties","text":"<ul> <li>auth: Manages authentication operations using Firebase Authentication.</li> <li>storage: Provides access to Firebase Cloud Storage for storing user-generated content such as photos and videos.</li> <li>firestore: Offers a NoSQL cloud database to store and sync data for client- and server-side development.</li> <li>database: Provides access to Firebase Realtime Database for real-time synchronization and data persistence.</li> </ul> <p>The <code>shared</code> static constant ensures that there is only one instance (<code>FirebaseManager</code>) throughout the application, promoting a unified access point to Firebase services.</p> <p>The <code>init()</code> method initializes Firebase services if they haven't been configured (<code>FirebaseApp.configure()</code>). It sets up: - auth: Authentication service. - storage: Cloud Storage service. - firestore: Firestore service. - database: Realtime Database service.</p>"},{"location":"technical/Services/firebase/21firebaseintro/#conclusion","title":"Conclusion","text":"<p>The <code>FirebaseManager</code> class simplifies integration and management of Firebase services (Authentication, Firestore, Realtime Database, and Storage) within SwiftUI-based iOS applications. By utilizing the shared instance and following Firebase best practices, you can enhance security, scalability, and efficiency in your application.</p> <p>You can access Firebase services through the shared instance of <code>FirebaseManager</code>.</p>"},{"location":"technical/Services/firebase/22auth/","title":"Authentication","text":"<p>The application employs two authentication systems to manage user access and functionality securely.</p>"},{"location":"technical/Services/firebase/22auth/#1-web-content-authentication-system","title":"1. Web Content Authentication System","text":"<p>The Web Content Authentication System is closely integrated with an AWS database, detailed comprehensively in the support documentation. This system serves as the initial authentication check within the application. If a user is not registered in this system, access to the Firebase Authentication system will not proceed.</p>"},{"location":"technical/Services/firebase/22auth/#integration-details","title":"Integration Details","text":"<ul> <li>Linked with Firebase: Firebase Authentication is closely integrated with the Web Content Authentication System.</li> <li>Registration Process: Registration is handled through a WebView, seamlessly integrating application-related information from AWS services.</li> </ul> <p>For more information regarding application-specific details, refer to the AWS service page.</p>"},{"location":"technical/Services/firebase/22auth/#2-firebase-authentication-system","title":"2. Firebase Authentication System","text":"<p>The Firebase Authentication System is essential for features such as Daily Login Rewards and In-App Chat Services. This section provides technical insights into the Firebase Authentication implementation.</p>"},{"location":"technical/Services/firebase/22auth/#functionality","title":"Functionality","text":"<ul> <li>Purpose: Facilitates secure user authentication necessary for accessing Daily Login Rewards and enabling In-App Chat functionalities.</li> <li>Integration: Seamlessly integrates with other Firebase services to ensure a robust and secure user experience.</li> </ul> <p>This documentation focuses on the technical aspects of the Firebase Authentication System and its role within the application architecture.</p>"},{"location":"technical/Services/firebase/22auth/#overview","title":"Overview","text":"<p>The authentication service of the iOS application utilizes Firebase Authentication, a robust platform provided by Google Firebase. Firebase Authentication offers secure and easy-to-use authentication methods, supporting authentication using passwords, phone numbers, popular identity providers like Google, Facebook, and more.</p> <p>This document provides a comprehensive guide on integration and how to utilizing Firebase Authentication within iOS application.</p> <p>Currently Only email and password sign-in method enabled. Provided email&amp;password should already registered web content otherwise user cannot registered in Firestore. User UID generated by firebase this uid also used in Cloud Firestore Database. </p>"},{"location":"technical/Services/firebase/22auth/#firebase-setup","title":"Firebase Setup","text":"<ol> <li> <p>Create Firebase Project:</p> <ul> <li>Go to the Firebase Console (https://console.firebase.google.com/) and create a new project.</li> <li>Follow the setup instructions to add your iOS app to the Firebase project.</li> </ul> </li> <li> <p>Add Firebase SDK:</p> <ul> <li>In your Xcode project, integrate Firebase SDK using Cocoapods or manually by downloading the Firebase SDK from the Firebase Console.</li> </ul> </li> <li> <p>Configure Firebase Authentication:</p> <ul> <li>Enable Authentication service in Firebase Console under the \"Authentication\" section.</li> <li>Configure sign-in methods (e.g., Email/Password, Google Sign-In) as per your application's requirements.</li> </ul> </li> <li> <p>Setup Firebase.plist:</p> <ul> <li>Download <code>GoogleService-Info.plist</code> from Firebase Console and add it to your Xcode project.</li> <li>Ensure the plist is correctly configured with your Firebase project details.</li> </ul> </li> </ol>"},{"location":"technical/Services/firebase/22auth/#authenticationmanager-class","title":"AuthenticationManager Class","text":"<p>The <code>FirebaseUserInfoViewModel</code> class is designed to manage user data and authentication using Firebase services within an iOS application. It utilizes various Firebase modules such as Authentication, Firestore, and Storage to handle user authentication, data storage, and retrieval.</p> <p>This documentation provides an overview of the class structure, its methods, and how to integrate and use it in your iOS application.</p>"},{"location":"technical/Services/firebase/22auth/#dependencies","title":"Dependencies","text":"<p>To use <code>FirebaseUserInfoViewModel</code>, ensure the following Firebase modules are integrated into your project using CocoaPods or manually: - FirebaseAuth - FirebaseFirestore - FirebaseDatabase - FirebaseStorage - FirebaseMessaging</p>"},{"location":"technical/Services/firebase/22auth/#class-structure","title":"Class Structure","text":"<p>Ensure you have the Firebase configuration set up correctly in your project. Instantiate the <code>FirebaseUserInfoViewModel</code> class where needed in your SwiftUI views or controllers.</p> <pre><code>let firebaseViewModel = FirebaseUserInfoViewModel()\n</code></pre>"},{"location":"technical/Services/firebase/22auth/#authentication-functions","title":"Authentication Functions","text":""},{"location":"technical/Services/firebase/22auth/#creating-a-new-user","title":"Creating a New User","text":"<pre><code>firebaseViewModel.firebaseCreateUser_Login(email: \"user@example.com\", password: \"password123\", userID: \"uniqueUserID\")\n</code></pre> <p>This function creates a new Firebase user with the provided email, password, and user ID. It also saves default user information to Firestore upon successful creation.</p>"},{"location":"technical/Services/firebase/22auth/#signing-in","title":"Signing In","text":"<pre><code>firebaseViewModel.firebaseSignIn(email: \"user@example.com\", password: \"password123\")\n</code></pre> <p>Signs in an existing user with the provided email and password. Updates daily login, current level data, and resets consecutive login counts upon successful sign-in.</p>"},{"location":"technical/Services/firebase/22auth/#deleting-account","title":"Deleting Account","text":"<pre><code>await firebaseViewModel.deleteFirebaseAccount()\n</code></pre> <p>Deletes the current user's Firebase account and associated Firestore document asynchronously. Handles errors if user is not logged in or deletion fails.</p>"},{"location":"technical/Services/firebase/22auth/#saving-user-information","title":"Saving User Information","text":"<pre><code>firebaseViewModel.saveUserInformation(userID: \"uniqueUserID\", shopPoint: 0, totalExp: 0, consecutiveLogin: 0, totalLogin: 1, level: 1, ownedItems: [], expBoosterEndDay: Date.now, lastLogin: Date.now, dailyReward: true, missionRewards: [true,true,true,true,true,true,true], blockedUsers: [], invisibleMsgs: [], fcmToken: \"\")\n</code></pre> <p>Saves user information to Firestore. This function should typically be called after creating a new user or upon initial login to set default values.</p>"},{"location":"technical/Services/firebase/22auth/#security-considerations","title":"Security Considerations","text":"<ul> <li>Ensure Firebase Security Rules are correctly configured to restrict access to user data based on user roles and authentication status.</li> <li>Avoid storing sensitive information such as passwords or API keys directly in Firestore or in user documents.</li> <li>Firebase Security Rules: Configure Firebase Security Rules to define who has read and write access to your data.</li> <li>Sensitive Data: Avoid storing sensitive information in Firebase Authentication custom claims or user profiles.</li> </ul>"},{"location":"technical/Services/firebase/22auth/#conclusion","title":"Conclusion","text":"<p>The <code>FirebaseUserInfoViewModel</code> provides a structured approach to handle user authentication and data management using Firebase services in SwiftUI-based iOS applications. By following the provided guidelines, you can integrate and utilize Firebase effectively to manage user authentication and data securely.</p> <p>For more detailed information on Firebase services and integration, refer to the Firebase Documentation.</p> <p>Implementing Firebase Authentication in your iOS application provides a secure and reliable way to authenticate users using various methods. Ensure to follow best practices and Firebase guidelines to enhance security and user experience.</p> <p>For more details on Firebase Authentication, refer to the Firebase Authentication Documentation.</p> <p>This technical documentation outlines the functionalities and integration of the <code>FirebaseUserInfoViewModel</code> class for managing user authentication and data in an iOS application using Firebase services.</p>"},{"location":"technical/Services/firebase/23storage/","title":"Storage","text":""},{"location":"technical/Services/firebase/23storage/#overview","title":"Overview","text":"<p>This document provides an overview of how Firebase Storage is integrated into our iOS application to handle file storage and retrieval.</p>"},{"location":"technical/Services/firebase/23storage/#features","title":"Features","text":"<ul> <li>File Upload: Users can upload various types of files (images, videos, documents) to Firebase Storage.</li> <li>File Download: Users can download files previously uploaded to Firebase Storage.</li> <li>Security Rules: Firebase Security Rules are implemented to restrict access to files based on user authentication and authorization.</li> </ul>"},{"location":"technical/Services/firebase/23storage/#usage","title":"Usage","text":""},{"location":"technical/Services/firebase/23storage/#file-upload","title":"File Upload","text":"<ol> <li>Upload Task<ul> <li>Use <code>StorageReference</code> to get a reference to the file in Firebase Storage.</li> <li>Use <code>putFile</code> or <code>putData</code> methods to upload files.</li> </ul> </li> </ol> <pre><code>let storage = Storage.storage()\nlet storageRef = storage.reference()\n\n// Local file you want to upload\nlet localFile = URL(fileURLWithPath: \"path/to/local/file\")\n\n// Create a reference to the file you want to upload\nlet fileRef = storageRef.child(\"path/to/destination/file\")\n\n// Upload file to Firebase Storage\nlet uploadTask = fileRef.putFile(from: localFile, metadata: nil) { metadata, error in\n    guard let metadata = metadata else {\n        // Handle error\n        return\n    }\n    // Metadata contains file metadata such as size, content-type, etc.\n}\n</code></pre>"},{"location":"technical/Services/firebase/23storage/#file-download","title":"File Download","text":"<ol> <li>Download Task<ul> <li>Use <code>getData</code> or <code>write</code> methods to download files from Firebase Storage.</li> </ul> </li> </ol> <pre><code>// Reference to an image file in Firebase Storage\nlet storageRef = Storage.storage().reference(withPath: \"path/to/file\")\n\n// Download in memory with a maximum allowed size of 1MB (1 * 1024 * 1024 bytes)\nstorageRef.getData(maxSize: 1 * 1024 * 1024) { data, error in\n    if let error = error {\n        // Handle any errors\n    } else {\n        // Data for \"path/to/file\" is returned\n        let image = UIImage(data: data!)\n        // Use the image\n    }\n}\n</code></pre>"},{"location":"technical/Services/firebase/23storage/#security-rules","title":"Security Rules","text":"<ol> <li> <p>Firebase Console</p> <ul> <li>Security rules in the Firebase Console under \"Storage\".</li> </ul> <pre><code>service firebase.storage {\n    match /b/{bucket}/o {\n        match /{allPaths=**} {\n            allow read, write: if request.auth != null;\n        }\n    }\n}\n</code></pre> </li> </ol> <p>This document has outlined the usage of Firebase Storage in our iOS application for file upload, download, and security rules implementation. For further details, refer to the Firebase documentation at Firebase Storage Documentation.</p>"},{"location":"technical/Services/firebase/23storage/#files-structure","title":"Files Structure","text":"<p>There are six folders existing in storage:</p> <ul> <li>Animated Emoji</li> <li>Background</li> <li>Button Image</li> <li>Chat Images</li> <li>Emoji</li> <li>Levels Logo</li> </ul> <p>To optimize resource usage within the application and minimize Firebase requests under the free tier, background and button images are integrated as local assets. The application is designed to retrieve these assets locally rather than from Firebase storage.</p> <p>Rules for saving files in storage:</p> <ul> <li>Animated Emoji: <code>[File Group Name]/file.png</code></li> <li>Background: <code>[File Group Name]/file.png</code></li> <li>Button Image: <code>[File Group Name]/file.png</code></li> <li>Emoji: <code>[File Group Name]/file.png</code></li> <li>Levels Logo: <code>Level[level name with 2 digits].png</code></li> <li>Chat Image: <code>File name.png</code></li> </ul> <p>The filename for chat images is generated by <code>MsgMenuModel.swift</code>. Check more details in here.</p> <p>There no extension is for this service in Firebase.</p>"},{"location":"technical/Services/firebase/24messaging/","title":"Messaging","text":"<p>Firebase Cloud Messaging Overview</p> <p>Firebase Messaging Service primarily functions as a notification service. It facilitates the delivery of notifications to users for various events such as new streams, incoming chat messages, updates on new versions, and other relevant notifications.</p> <p>Authentication</p> <p>Firebase Messaging Service employs OAuth 2.0 authentication, requiring an API access token for utilizing the Firebase Cloud Messaging service. The following source code outlines how to obtain the access token, includes logic for checking expiration times, and demonstrates sending messages to users.</p> <p>Using Firebase Cloud Messaging</p> <p>Firebase Cloud Messaging (FCM) enables developers to send notifications and messages to users. </p> <p><code>NotificationManager.swift</code> automatically handles notifications between users. Notifications sent from administrators can be managed using the Firebase Messaging Console.</p> <p>For detailed instructions and best practices on using Firebase Cloud Messaging effectively, refer to the Firebase documentation here.</p>"},{"location":"technical/Services/firebase/24messaging/#notfication-manager","title":"Notfication Manager","text":""},{"location":"technical/Services/firebase/24messaging/#overview","title":"Overview","text":"<p><code>NotificationManager.swift</code> manages user notification permissions and Firebase Cloud Messaging (FCM) for the Cheer Supports iOS application. It handles notification permissions, sends notifications to users, and manages Firebase API access tokens.</p>"},{"location":"technical/Services/firebase/24messaging/#class-notificationmanager","title":"Class: NotificationManager","text":"<p><code>NotificationManager</code> is an <code>ObservableObject</code> responsible for managing notifications and API access tokens.</p>"},{"location":"technical/Services/firebase/24messaging/#properties","title":"Properties","text":"<ul> <li>hasPermission: Indicates whether the app has notification permissions.</li> <li>accessToken: Stores the current Google API access token for Firebase messaging.</li> <li>fcm_list: An array storing FCM tokens of users currently using the app.</li> </ul>"},{"location":"technical/Services/firebase/24messaging/#initialization","title":"Initialization","text":"<p>The <code>NotificationManager</code> is initialized asynchronously to check and set notification permissions.</p>"},{"location":"technical/Services/firebase/24messaging/#methods","title":"Methods","text":"<ol> <li> <p>request(): Requests notification permissions from the user asynchronously using <code>UNUserNotificationCenter</code>.</p> </li> <li> <p>getAuthStatus(): Checks the current notification authorization status asynchronously.</p> </li> <li> <p>sendMessageToDevice(msg: String, title: String): Sends a notification to all users using Firebase Cloud Messaging. It constructs a JSON payload and sends it via HTTP POST request.</p> </li> <li> <p>getAllFCMToken(): Retrieves all FCM tokens from Firestore for users currently using the app.</p> </li> <li> <p>isAccessTokenExpired(): Checks if the current Google API access token is expired asynchronously.</p> </li> <li> <p>updateAccessToken(): Updates the Google API access token asynchronously using <code>ServiceAccountTokenProvider</code>.</p> </li> <li> <p>getAccessToken(): Retrieves the current valid Google API access token asynchronously. It checks for expiration and updates if necessary.</p> </li> <li> <p>updateFirebaseNotificationValues(): Updates Firebase Firestore with the current API access token and expiry time.</p> </li> </ol>"},{"location":"technical/Services/firebase/24messaging/#error-handling","title":"Error Handling","text":"<ul> <li>Errors related to Firebase operations, network requests, and token management are logged but not explicitly handled within this class.</li> </ul>"},{"location":"technical/Services/firebase/24messaging/#usage","title":"Usage","text":"<p>To use <code>NotificationManager</code>, initialize an instance and call its methods asynchronously to manage notification permissions and send notifications.</p>"},{"location":"technical/Services/firebase/24messaging/#example","title":"Example","text":"<pre><code>// Example usage of NotificationManager\n\nlet notificationManager = NotificationManager()\n\n// Request notification permissions\nawait notificationManager.request()\n\n// Send a notification\ndo {\n    await notificationManager.sendMessageToDevice(msg: \"Hello from Cheer Supports!\", title: \"New Message\")\n} catch {\n    print(\"Error sending notification: \\(error.localizedDescription)\")\n}\n</code></pre>"},{"location":"technical/Services/firebase/24messaging/#dependencies","title":"Dependencies","text":"<pre><code>- Firebase SDK (Firestore, Core, Authentication)\n- OAuth2 library for managing API access tokens\n</code></pre> <p>This documentation provides an overview of <code>NotificationManager.swift</code> functionality, its methods, properties, and usage examples within the Cheer Supports application context. Adjust details and add specific error handling or usage examples as needed for comprehensive documentation.</p>"},{"location":"technical/Services/firebase/25firestore/","title":"Firestore","text":""},{"location":"technical/Services/firebase/25firestore/#1-introduction","title":"1. Introduction","text":"<p>This document serves as a technical guide for developers involved in the iOS app development project utilizing Firebase Cloud Firestore.</p>"},{"location":"technical/Services/firebase/25firestore/#2-firebase-cloud-firestore-overview","title":"2. Firebase Cloud Firestore Overview","text":""},{"location":"technical/Services/firebase/25firestore/#features","title":"Features","text":"<ul> <li>Real-time database synchronization</li> <li>Scalable NoSQL database</li> <li>Automatic and efficient data syncing</li> </ul>"},{"location":"technical/Services/firebase/25firestore/#benefits","title":"Benefits","text":"<ul> <li>Seamless integration with Firebase ecosystem</li> <li>Robust querying capabilities</li> <li>Reliable offline support</li> </ul>"},{"location":"technical/Services/firebase/25firestore/#integration-with-ios","title":"Integration with iOS","text":"<ul> <li>Firebase SDK integration</li> <li>Authentication and security features</li> <li>Cloud Functions for backend logic</li> </ul>"},{"location":"technical/Services/firebase/25firestore/#3-collections-and-document-structure","title":"3. Collections and Document Structure","text":"<p>The app utilizes five main collections within Firebase Cloud Firestore:</p> <ul> <li>Levels</li> <li>Msgs</li> <li>Notification</li> <li>Users</li> <li>Report</li> </ul> <p>Each collection has a specific purpose and is structured to efficiently store and retrieve data relevant to the application's functionality.</p>"},{"location":"technical/Services/firebase/25firestore/#4-levels-collection","title":"4. Levels Collection","text":"<p>The Levels collection stores data related to the level and its capacity. This system distinguishes between active and inactive users. Active users are eligible to receive free items.</p>"},{"location":"technical/Services/firebase/25firestore/#5-msgs-collection","title":"5. Msgs Collection","text":"<p>The Msgs collection stores messages or chat data exchanged within the app.</p> <p>The Msgs collection in Firebase Firestore manages data related to messages sent within the application. This collection is crucial for storing and retrieving communication content between users, facilitating seamless interaction and communication features.</p> <p>The Msgs collection serves several key purposes:</p> <ul> <li> <p>Communication: Stores textual content and multimedia attachments exchanged between users, facilitating seamless communication and interaction within the application.</p> </li> <li> <p>Content Management: Manages URLs to external resources or attachments associated with messages, enriching message content and enhancing user experience.</p> </li> <li> <p>Timestamp Tracking: Records the precise time and date of message interactions, enabling chronological organization and historical reference within message threads.</p> </li> <li> <p>User Identification: Associates messages with specific users (identified by <code>userID</code>), ensuring message attribution and facilitating targeted communication features.</p> </li> </ul>"},{"location":"technical/Services/firebase/25firestore/#6-notification-collection","title":"6. Notification Collection","text":"<p>The Notification collection manages access tokens and service account information necessary for authentication and secure communication with external services.</p>"},{"location":"technical/Services/firebase/25firestore/#7-users-collection","title":"7. Users Collection","text":"<p>The User collection in Firebase Firestore stores essential data related to user activities and preferences within the application. This collection is pivotal for maintaining user-specific information and enhancing personalized user experiences.</p> <p>The User collection serves several key purposes:</p> <ul> <li>Personalization: Stores user-specific settings, preferences, and progress data to tailor the application experience.</li> <li>Engagement: Tracks user activity metrics such as login streaks, rewards claimed, and mission progress to enhance user engagement and retention.</li> <li>Data Management: Facilitates efficient management of user-related data, ensuring seamless operation and scalability of the application.</li> <li>Analytics: Provides valuable insights into user behavior and interaction patterns, informing strategic decisions and feature enhancements.</li> </ul>"},{"location":"technical/Services/firebase/25firestore/#8-report-collection","title":"8. Report Collection","text":"<p>The Report collection stores user-generated reports or feedback submitted within the app.</p>"},{"location":"technical/Services/firebase/25firestore/#9-security-rules","title":"9. Security Rules","text":"<p>Firebase Cloud Firestore security rules are implemented to restrict access and ensure data privacy and integrity.</p>"},{"location":"technical/Services/firebase/25firestore/#10-maintenance-and-updates","title":"10. Maintenance and Updates","text":"<p>Guidelines for maintaining and updating Firestore collections and app integration over time.</p> <p>This technical documentation provides comprehensive guidance on utilizing Firebase Cloud Firestore for an iOS app, specifically focusing on the five collections: Levels, Msgs, Notification, Users, and Report. It serves as a valuable resource for developers involved in the project's lifecycle.</p>"}]}